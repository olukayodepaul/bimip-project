syntax = "proto3";

package bimip;

// ---------------- Identity ----------------
// Represents a user and optionally a specific device/session
message Identity {
  string eid = 1;                               // User’s global identifier (e.g., account ID or JID)
  optional string connection_resource_id = 2;   // Identifier for a specific device or session instance
}

// ---------------- Awareness ----------------
// Sends a user’s awareness (presence, location, and status) to other users
message Awareness {
  string from = 1;                 // Sender (uses eid only)
  string to = 2;                   // Recipient (uses eid only)
  int32 status = 3;                  // Presence state: 1=ONLINE, 2=OFFLINE, 3=AWAY, 4=BUSY, 5=DND, 6=INVISIBLE, 7=IDLE, 8=UNKNOWN
  bool location_sharing = 4;
  double latitude = 5;               // Latitude
  double longitude = 6;              // Longitude
  int32 intention = 7;     // Broadcast control: 1=DO_NOT_BROADCAST, 2=BROADCAST
  int64 timestamp = 8; 
}

// ---------------- ErrorMessage ----------------
// Represents an error response with code, description, and optional details
// ---------------- ResponseStatus ----------------
// Generic response status for any stanza.
// Important Status Codes:
//   200 = OK                    → Operation successful
//   100 = INVALID_REQUEST       → Malformed or missing fields
//   401 = UNAUTHORIZED          → Invalid or missing authentication
//   408 = TIMEOUT               → Request or ping timed out
//   500 = INTERNAL_ERROR        → Server/device error
//   600 = DEVICE_DISCONNECTED   → Target device lost connection
//   601 = SOCKET_TERMINATED     → Socket closed by client or server
//   602 = SESSION_EXPIRED       → Token/session no longer valid
//   604 = FORCE_LOGOUT          → Session terminated by server/mother
message ErrorMessage {
  int32 code = 1;       // See list above
  int32 error_origin = 2;     // Route or context where the status originated
  string details = 3;   // Additional info (optional)
  int64 timestamp = 4; 
}

// ---------------- LogoutMessage ----------------
// Uses both eid and connection_resource_id to log out a specific device
message Logout {
  Identity to = 1;      // The user/device performing logout
  int32 type = 2;           // 1 = REQUEST, 2 = RESPONSE
  int32 status = 3;         // 1 = DISCONNECT, 2 = FAIL, 3 = SUCCESS, 4 = PENDING
  int64 timestamp = 4;      // Unix UTC timestamp (ms) of the action
}

// ---------------- PingPong ----------------
// Heartbeat messages from client to server to check connectivity of a specific device (Identity includes both eid and connection_resource_id)
// Client generates ping_id; server echoes it back in PONG with pong_time
message PingPong {
  Identity to = 1;              // Server identity, includes both eid and connection_resource_id to identify the target device/session
  int32 type = 2;               // Message type: 1=PING (from client), 2=PONG (from server)
  int64 ping_time = 3;          // Timestamp when client sent the PING (Unix UTC, ms)
  int64 pong_time = 4;          // Timestamp when server sent the PONG (Unix UTC, ms)
  string ping_id = 5;           // Unique identifier for this PING, generated by client and echoed in PONG
}

// ---------------- TokenRevokeRequest ----------------
// Client requests to revoke a specific token (e.g., for logout, security, or device change).
// `to` specifies the server/device responsible for revoking.
// `reason` is optional but useful for auditing and explaining forced revokes.

message TokenRevokeRequest {
  Identity to     = 1;
  string token    = 2;
  int64 timestamp = 3;
  string reason   = 4;   // e.g., "LOGOUT", "COMPROMISED", "SESSION_EXPIRED"
}

message TokenRevokeResponse {
  Identity to = 1;
  int32 status = 2;       // 1=SUCCESS, 2=FAILED
  int64 timestamp = 3;
  string reason = 4;      // optional: provides explanation if status=FAILED
}

// ---------------- SubscribeRequest ----------------
// A user (from) requests to connect with another user (to).
// The `subscription_id` uniquely identifies this subscription attempt.
// Note: Only `eid` is needed in Identity for subscription.
// Default behavior is **two-way mutual subscription**.
// If `one_way=true`, only the sender will see the target's updates; target won't automatically see sender's updates.
message SubscribeRequest {
  Identity from = 1;           // Request sender (A)
  Identity to = 2;             // Target user (B)
  string subscription_id = 3;  // Unique ID for this subscription (UUID or client-generated)
  bool one_way = 4;            // Optional: true = one-way subscription; default=false (two-way)
  int64 timestamp = 5;         // When the request was sent
}

// ---------------- SubscribeResponse ----------------
// The target user (to) accepts or rejects a subscription request.
// Linked to the original request via `subscription_id`.
// `one_way` echoes the subscription type chosen by the requester.
message SubscribeResponse {
  Identity from = 1;           // The responder (B)
  Identity to = 2;             // Original requester (A)
  int32 status = 3;            // 1=ACCEPTED, 2=REJECTED
  string message = 4;          // Optional reason (e.g., "User rejected request")
  string subscription_id = 5;  // Matches SubscribeRequest.subscription_id
  bool one_way = 6;            // True if subscription is one-way, false if two-way (default)
  int64 timestamp = 7;         // Response time
}

// ---------------- UnsubscribeRequest ----------------
// Used when a user (`from`) unsubscribes from another user (`to`) to stop receiving updates.
// For two-way subscriptions, removal can be mutual by default.
// NOTE: `from` and `to` MUST only use `eid`.
// The `connection_resource_id` MUST be nil (not set).
message UnsubscribeRequest {
  Identity from = 1;                 // The user initiating the unsubscribe (eid only)
  Identity to = 2;                   // The user being unsubscribed from (eid only)
  int64 timestamp = 3;               // Time the request was created
  bool force_two_way_removal = 4;    // Optional: true to remove both sides even if one-way subscription
}

// ---------------- UnsubscribeResponse ----------------
// Sent back to confirm whether the unsubscribe succeeded or failed.
// NOTE: `from` and `to` MUST only use `eid`.
// The `connection_resource_id` MUST be nil (not set).
message UnsubscribeResponse {
  Identity from = 1;          // The requester (eid only)
  Identity to = 2;            // The target being unsubscribed from (eid only)
  int32 status = 3;           // 1=SUCCESS, 2=FAILED
  string message = 4;         // Human-readable status info
  int64 timestamp = 5;        // Time the response was generated
  bool two_way_removed = 6;   // True if both sides were removed; false if only initiator side removed
}


// ---------------- MessageScheme ----------------
// Wrapper for all messaging protocol types
message MessageScheme {
  int64 route = 1;  // Unique route identifier for message routing

  oneof payload {
    Awareness awareness  = 2;  // User awareness/presence update
    PingPong ping_pong                            = 3;
    TokenRevokeRequest token_revoke_request       = 4;
    TokenRevokeResponse token_revoke_response     = 5;
    SubscribeRequest subscribe_request            = 6;
    SubscribeResponse subscribe_response          = 7;
    UnsubscribeRequest unsubscribe_request        = 8;
    UnsubscribeResponse unsubscribe_response      = 9;
    Logout logout                                 = 10; // Logout message
    ErrorMessage error                            = 11; // Error message
  }
}